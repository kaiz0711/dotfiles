--# selene: allow(unused_variable)
---@diagnostic disable: unused-local

-- Like |screenchar()|, but return the attribute.  This is a rather
-- 		arbitrary number that can only be used to compare to the
-- 		attribute at other positions.
--- @return number
function vim.fn.screenattr(row, col) end

-- {textlist} must be a |List| of strings.  This |List| is
-- 		displayed, one string per line.  The user will be prompted to
-- 		enter a number, which is returned.
-- 		The user can also select an item by clicking on it with the
-- 		mouse.  For the first string 0 is returned.  When clicking
-- 		above the first item a negative number is returned.  When
-- 		clicking on the prompt one more than the length of {textlist}
-- 		is returned.
-- 		Make sure {textlist} has less than 'lines' entries, otherwise
-- 		it won't work.  It's a good idea to put the entry number at
-- 		the start of the string.  And put a prompt in the first item.
-- 		Example: >
-- 			let color = inputlist(['Select color:', '1. red',
-- 				\ '2. green', '3. blue'])
--- @return number
function vim.fn.inputlist(textlist) end

-- The result is a Number, which is the character at position
-- 		[row, col] on the screen.  This works for every possible
-- 		screen position, also status lines, window separators and the
-- 		command line.  The top left position is row one, column one
-- 		The character excludes composing characters.  For double-byte
-- 		encodings it may only be the first byte.
-- 		This is mainly to be used for testing.
-- 		Returns -1 when row or col is out of range.
--- @return number
function vim.fn.screenchar(row, col) end

-- Like byteidx(), except that a composing character is counted
-- 		as a separate character.  Example: >
-- 			let s = 'e' . nr2char(0x301)
-- 			echo byteidx(s, 1)
-- 			echo byteidxcomp(s, 1)
-- 			echo byteidxcomp(s, 2)
-- <		The first and third echo result in 3 ('e' plus composing
-- 		character is 3 bytes), the second echo results in 1 ('e' is
-- 		one byte).
--- @return number
function vim.fn.byteidxcomp(expr, nr) end

-- The result is a Number, which is the current screen column of
-- 		the cursor. The leftmost column has number 1.
-- 		This function is mainly used for testing.
--
-- 		Note: Always returns the current screen column, thus if used
-- 		in a command (e.g. ":echo screencol()") it will return the
-- 		column inside the command line, which is 1 when the command is
-- 		executed. To get the cursor position in the file use one of
-- 		the following mappings: >
-- 			nnoremap <expr> GG ":echom ".screencol()."\n"
-- 			nnoremap <silent> GG :echom screencol()<CR>
-- 			noremap GG <Cmd>echom screencol()<Cr>
--- @return number
function vim.fn.screencol() end

-- Returns the single letter name of the register being executed.
-- 		Returns an empty string when no register is being executed.
-- 		See |@|.
--- @return string
function vim.fn.reg_executing() end

-- Add {expr} to the list of matches.  Only to be used by the
-- 		function specified with the 'completefunc' option.
-- 		Returns 0 for failure (empty string or out of memory),
-- 		1 when the match was added, 2 when the match was already in
-- 		the list.
-- 		See |complete-functions| for an explanation of {expr}.  It is
-- 		the same as one item in the list that 'omnifunc' would return.
--- @return number
function vim.fn.complete_add(expr) end

-- Return the number of the most recent change.  This is the same
-- 		number as what is displayed with |:undolist| and can be used
-- 		with the |:undo| command.
-- 		When a change was made it is the number of that change.  After
-- 		redo it is the number of the redone change.  After undo it is
-- 		one less than the number of the undone change.
--- @return number
function vim.fn.changenr() end

-- Check for a key typed while looking for completion matches.
-- 		This is to be used when looking for matches takes some time.
-- 		Returns |TRUE| when searching for matches is to be aborted,
-- 		zero otherwise.
-- 		Only to be used by the function specified with the
-- 		'completefunc' option.
--- @return number
function vim.fn.complete_check() end

-- Close a channel or a specific stream associated with it.
-- 		For a job, {stream} can be one of "stdin", "stdout",
-- 		"stderr" or "rpc" (closes stdin/stdout for a job started
-- 		with `"rpc":v:true`) If {stream} is omitted, all streams
-- 		are closed. If the channel is a pty, this will then close the
-- 		pty master, sending SIGHUP to the job process.
-- 		For a socket, there is only one stream, and {stream} should be
-- 		ommited.
--- @return number
function vim.fn.chanclose(id, stream) end

-- Search for the declaration of {name}.
--
-- 		With a non-zero {global} argument it works like |gD|, find
-- 		first match in the file.  Otherwise it works like |gd|, find
-- 		first match in the function.
--
-- 		With a non-zero {thisblock} argument matches in a {} block
-- 		that ends before the cursor position are ignored.  Avoids
-- 		finding variable declarations only valid in another scope.
--
-- 		Moves the cursor to the found match.
-- 		Returns zero for success, non-zero for failure.
-- 		Example: >
-- 			if searchdecl('myvar') == 0
-- 			   echo getline('.')
-- 			endif
-- <
-- 							*searchpair()*
-- searchpair({start}, {middle}, {end} [, {flags} [, {skip}
-- 				[, {stopline} [, {timeout}]]]])
-- 		Search for the match of a nested start-end pair.  This can be
-- 		used to find the "endif" that matches an "if", while other
-- 		if/endif pairs in between are ignored.
-- 		The search starts at the cursor.  The default is to search
-- 		forward, include 'b' in {flags} to search backward.
-- 		If a match is found, the cursor is positioned at it and the
-- 		line number is returned.  If no match is found 0 or -1 is
-- 		returned and the cursor doesn't move.  No error message is
-- 		given.
--
-- 		{start}, {middle} and {end} are patterns, see |pattern|.  They
-- 		must not contain \( \) pairs.  Use of \%( \) is allowed.  When
-- 		{middle} is not empty, it is found when searching from either
-- 		direction, but only when not in a nested start-end pair.  A
-- 		typical use is: >
-- 			searchpair('\<if\>', '\<else\>', '\<endif\>')
-- <		By leaving {middle} empty the "else" is skipped.
--
-- 		{flags} 'b', 'c', 'n', 's', 'w' and 'W' are used like with
-- 		|search()|.  Additionally:
-- 		'r'	Repeat until no more matches found; will find the
-- 			outer pair.  Implies the 'W' flag.
-- 		'm'	Return number of matches instead of line number with
-- 			the match; will be > 1 when 'r' is used.
-- 		Note: it's nearly always a good idea to use the 'W' flag, to
-- 		avoid wrapping around the end of the file.
--
-- 		When a match for {start}, {middle} or {end} is found, the
-- 		{skip} expression is evaluated with the cursor positioned on
-- 		the start of the match.  It should return non-zero if this
-- 		match is to be skipped.  E.g., because it is inside a comment
-- 		or a string.
-- 		When {skip} is omitted or empty, every match is accepted.
-- 		When evaluating {skip} causes an error the search is aborted
-- 		and -1 returned.
--  		{skip} can be a string, a lambda, a funcref or a partial.
-- 		Anything else makes the function fail.
--
-- 		For {stopline} and {timeout} see |search()|.
--
-- 		The value of 'ignorecase' is used.  'magic' is ignored, the
-- 		patterns are used like it's on.
--
-- 		The search starts exactly at the cursor.  A match with
-- 		{start}, {middle} or {end} at the next character, in the
-- 		direction of searching, is the first one found.  Example: >
-- 			if 1
-- 			  if 2
-- 			  endif 2
-- 			endif 1
-- <		When starting at the "if 2", with the cursor on the "i", and
-- 		searching forwards, the "endif 2" is found.  When starting on
-- 		the character just before the "if 2", the "endif 1" will be
-- 		found.  That's because the "if 2" will be found first, and
-- 		then this is considered to be a nested if/endif from "if 2" to
-- 		"endif 2".
-- 		When searching backwards and {end} is more than one character,
-- 		it may be useful to put "\zs" at the end of the pattern, so
-- 		that when the cursor is inside a match with the end it finds
-- 		the matching start.
--
-- 		Example, to find the "endif" command in a Vim script: >
--
-- 	:echo searchpair('\<if\>', '\<el\%[seif]\>', '\<en\%[dif]\>', 'W',
-- 			\ 'getline(".") =~ "^\\s*\""')
--
-- <		The cursor must be at or after the "if" for which a match is
-- 		to be found.  Note that single-quote strings are used to avoid
-- 		having to double the backslashes.  The skip expression only
-- 		catches comments at the start of a line, not after a command.
-- 		Also, a word "en" or "if" halfway through a line is considered
-- 		a match.
-- 		Another example, to search for the matching "{" of a "}": >
--
-- 	:echo searchpair('{', '', '}', 'bW')
--
-- <		This works when the cursor is at or before the "}" for which a
-- 		match is to be found.  To reject matches that syntax
-- 		highlighting recognized as strings: >
--
-- 	:echo searchpair('{', '', '}', 'bW',
-- 	     \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')
-- <
-- 							*searchpairpos()*
-- searchpairpos({start}, {middle}, {end} [, {flags} [, {skip}
-- 				[, {stopline} [, {timeout}]]]])
-- 		Same as |searchpair()|, but returns a |List| with the line and
-- 		column position of the match. The first element of the |List|
-- 		is the line number and the second element is the byte index of
-- 		the column position of the match.  If no match is found,
-- 		returns [0, 0]. >
--
-- 			:let [lnum,col] = searchpairpos('{', '', '}', 'n')
-- <
-- 		See |match-parens| for a bigger and more useful example.
--- @return number
function vim.fn.searchdecl(name, global, thisblock) end

-- Return number value of the first char in {expr}.  Examples: >
-- 			char2nr(" ")		returns 32
-- 			char2nr("ABC")		returns 65
-- 			char2nr("รก")		returns 225
-- 			char2nr("รก"[0])		returns 195
-- 			char2nr("\<M-x>")	returns 128
-- <		Non-ASCII characters are always treated as UTF-8 characters.
-- 		{utf8} is ignored, it exists only for backwards-compatibility.
-- 		A combining character is a separate character.
-- 		|nr2char()| does the opposite.
--- @return number
function vim.fn.char2nr(expr, utf8) end

--- @return number
function vim.fn.searchpair(start, middle, _end, flags, ...) end

-- Cleanup unused |Lists| and |Dictionaries| that have circular
-- 		references.
--
-- 		There is hardly ever a need to invoke this function, as it is
-- 		automatically done when Vim runs out of memory or is waiting
-- 		for the user to press a key after 'updatetime'.  Items without
-- 		circular references are always freed when they become unused.
-- 		This is useful if you have deleted a very big |List| and/or
-- 		|Dictionary| with circular references in a script that runs
-- 		for a long time.
--
-- 		When the optional {atexit} argument is one, garbage
-- 		collection will also be done when exiting Vim, if it wasn't
-- 		done before.  This is useful when checking for memory leaks.
--
-- 		The garbage collection is not done immediately but only when
-- 		it's safe to perform.  This is when waiting for the user to
-- 		type a character.
--- @return none
function vim.fn.garbagecollect(atexit) end

--- @return list
function vim.fn.searchpairpos(start, middle, _end, flags, ...) end

-- Checks for the existence of a |cscope| connection.  If no
-- 		parameters are specified, then the function returns:
-- 			0, if cscope was not available (not compiled in), or
-- 			   if there are no cscope connections;
-- 			1, if there is at least one cscope connection.
--
-- 		If parameters are specified, then the value of {num}
-- 		determines how existence of a cscope connection is checked:
--
-- 		{num}	Description of existence check
-- 		-----	------------------------------
-- 		0	Same as no parameters (e.g., "cscope_connection()").
-- 		1	Ignore {prepend}, and use partial string matches for
-- 			{dbpath}.
-- 		2	Ignore {prepend}, and use exact string matches for
-- 			{dbpath}.
-- 		3	Use {prepend}, use partial string matches for both
-- 			{dbpath} and {prepend}.
-- 		4	Use {prepend}, use exact string matches for both
-- 			{dbpath} and {prepend}.
--
-- 		Note: All string comparisons are case sensitive!
--
-- 		Examples.  Suppose we had the following (from ":cs show"): >
--
--   # pid    database name			prepend path
--   0 27664  cscope.out				/usr/local
-- <
-- 		Invocation					Return Val ~
-- 		----------					---------- >
-- 		cscope_connection()					1
-- 		cscope_connection(1, "out")				1
-- 		cscope_connection(2, "out")				0
-- 		cscope_connection(3, "out")				0
-- 		cscope_connection(3, "out", "local")			1
-- 		cscope_connection(4, "out")				0
-- 		cscope_connection(4, "out", "local")			0
-- 		cscope_connection(4, "cscope.out", "/usr/local")	1
-- <
--- @return number
function vim.fn.cscope_connection(num, dbpath, prepend) end

-- The result is the number of files in the argument list.  See
-- 		|arglist|.
-- 		If {winid} is not supplied, the argument list of the current
-- 		window is used.
-- 		If {winid} is -1, the global argument list is used.
-- 		Otherwise {winid} specifies the window of which the argument
-- 		list is used: either the window number or the window ID.
-- 		Returns -1 if the {winid} argument is invalid.
--- @return number
function vim.fn.argc(winid) end

-- Send a reply string to {clientid}.  The most recent {clientid}
-- 		that sent a string can be retrieved with expand("<client>").
-- 		Note:
-- 		This id has to be stored before the next command can be
-- 		received.  I.e. before returning from the received command and
-- 		before calling any commands that waits for input.
-- 		See also |clientserver|.
-- 		Example: >
-- 			:echo server2client(expand("<client>"), "HELLO")
--- @return number
function vim.fn.server2client(clientid, string) end

-- Returns a list of server addresses, or empty if all servers
-- 		were stopped. |serverstart()| |serverstop()|
-- 		Example: >
-- 			:echo serverlist()
--- @return string
function vim.fn.serverlist() end

-- Set line {lnum} to {text} in buffer {expr}.  To insert
-- 		lines use |append()|.
--
-- 		For the use of {expr}, see |bufname()| above.
--
-- 		{lnum} is used like with |setline()|.
-- 		This works like |setline()| for the specified buffer.
-- 		On success 0 is returned, on failure 1 is returned.
--
-- 		If {expr} is not a valid buffer or {lnum} is not valid, an
-- 		error message is given.
--- @return number
function vim.fn.setbufline(expr, lnum, line) end

-- Clears all matches previously defined for the current window
-- 		by |matchadd()| and the |:match| commands.
--- @return none
function vim.fn.clearmatches() end

-- Set option or local variable {varname} in buffer {expr} to
-- 		{val}.
-- 		This also works for a global or local window option, but it
-- 		doesn't work for a global or local window variable.
-- 		For a local window option the global value is unchanged.
-- 		For the use of {expr}, see |bufname()| above.
-- 		Note that the variable name without "b:" must be used.
-- 		Examples: >
-- 			:call setbufvar(1, "&mod", 1)
-- 			:call setbufvar("todo", "myvar", "foobar")
-- <		This function is not available in the |sandbox|.
--- @return set
function vim.fn.setbufvar(expr, varname, val) end

-- Open a new window displaying the contents of {filename}
-- 		The file must have been created with |term_dumpwrite()|.
-- 		Returns the buffer number or zero when it fails.
-- 		Also see |terminal-diff|.
--
-- 		For {options} see |term_dumpdiff()|.
--
-- 		Can also be used as a |method|: >
-- 			GetFilename()->term_dumpload()
-- <
--- @return number
function vim.fn.term_dumpload(filename, options) end

-- Returns the size of the |context-stack|.
--- @return number
function vim.fn.ctxsize() end

-- Make a copy of {expr}.  For Numbers and Strings this isn't
-- 		different from using {expr} directly.
-- 		When {expr} is a |List| a full copy is created.  This means
-- 		that the original |List| can be changed without changing the
-- 		copy, and vice versa.  When an item is a |List|, a copy for it
-- 		is made, recursively.  Thus changing an item in the copy does
-- 		not change the contents of the original |List|.
-- 		When {noref} is omitted or zero a contained |List| or
-- 		|Dictionary| is only copied once.  All references point to
-- 		this single copy.  With {noref} set to 1 every occurrence of a
-- 		|List| or |Dictionary| results in a new copy.  This also means
-- 		that a cyclic reference causes deepcopy() to fail.
-- 								*E724*
-- 		Nesting is possible up to 100 levels.  When there is an item
-- 		that refers back to a higher level making a deep copy with
-- 		{noref} set to 1 will fail.
-- 		Also see |copy()|.
function vim.fn.deepcopy(expr, noref) end

-- Set the cursor position in the command line to byte position
-- 		{pos}.  The first position is 1.
-- 		Use |getcmdpos()| to obtain the current position.
-- 		Only works while editing the command line, thus you must use
-- 		|c_CTRL-\_e|, |c_CTRL-R_=| or |c_CTRL-R_CTRL-R| with '='.  For
-- 		|c_CTRL-\_e| and |c_CTRL-R_CTRL-R| with '=' the position is
-- 		set after the command line is set to the expression.  For
-- 		|c_CTRL-R_=| it is set after evaluating the expression but
-- 		before inserting the resulting text.
-- 		When the number is too big the cursor is put at the end of the
-- 		line.  A number smaller than one has undefined results.
-- 		Returns 0 when successful, 1 when not editing the command
-- 		line.
--- @return number
function vim.fn.setcmdpos(pos) end

-- Return a |List| with all the key-value pairs of {dict}.  Each
-- 		|List| item is a list with two items: the key of a {dict}
-- 		entry and the value of this entry.  The |List| is in arbitrary
-- 		order.
--- @param dict dictionary
--- @return list
function vim.fn.items(dict) end

-- Specifically used to interrupt a program being debugged.  It
-- 		will cause process {pid} to get a SIGTRAP.  Behavior for other
-- 		processes is undefined. See |terminal-debugger|.
-- 		{Sends a SIGINT to a process {pid} other than MS-Windows}
--- @return number
function vim.fn.debugbreak(pid) end

-- Stop a timer.  The timer callback will no longer be invoked.
-- 		{timer} is an ID returned by timer_start(), thus it must be a
-- 		Number.  If {timer} does not exist there is no error.
--- @return none
function vim.fn.timer_stop(timer) end

-- Sort the items in {list} in-place.  Returns {list}.
--
-- 		If you want a list to remain unmodified make a copy first: >
-- 			:let sortedlist = sort(copy(mylist))
--
-- <		When {func} is omitted, is empty or zero, then sort() uses the
-- 		string representation of each item to sort on.  Numbers sort
-- 		after Strings, |Lists| after Numbers.  For sorting text in the
-- 		current buffer use |:sort|.
--
-- 		When {func} is given and it is '1' or 'i' then case is
-- 		ignored.
--
-- 		When {func} is given and it is 'n' then all items will be
-- 		sorted numerical (Implementation detail: This uses the
-- 		strtod() function to parse numbers, Strings, Lists, Dicts and
-- 		Funcrefs will be considered as being 0).
--
-- 		When {func} is given and it is 'N' then all items will be
-- 		sorted numerical. This is like 'n' but a string containing
-- 		digits will be used as the number they represent.
--
-- 		When {func} is given and it is 'f' then all items will be
-- 		sorted numerical. All values must be a Number or a Float.
--
-- 		When {func} is a |Funcref| or a function name, this function
-- 		is called to compare items.  The function is invoked with two
-- 		items as argument and must return zero if they are equal, 1 or
-- 		bigger if the first one sorts after the second one, -1 or
-- 		smaller if the first one sorts before the second one.
--
-- 		{dict} is for functions with the "dict" attribute.  It will be
-- 		used to set the local variable "self". |Dictionary-function|
--
-- 		The sort is stable, items which compare equal (as number or as
-- 		string) will keep their relative position. E.g., when sorting
-- 		on numbers, text strings will sort next to each other, in the
-- 		same order as they were originally.
--
-- 		Also see |uniq()|.
--
-- 		Example: >
-- 			func MyCompare(i1, i2)
-- 			   return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1
-- 			endfunc
-- 			let sortedlist = sort(mylist, "MyCompare")
-- <		A shorter compare version for this specific simple case, which
-- 		ignores overflow: >
-- 			func MyCompare(i1, i2)
-- 			   return a:i1 - a:i2
-- 			endfunc
-- <
--- @param list any[]
--- @param dict dictionary
--- @return list
function vim.fn.sort(list, func, dict) end

-- Convert a |readfile()|-style list to a list of VimL objects.
-- 		Example: >
-- 			let fname = expand('~/.config/nvim/shada/main.shada')
-- 			let mpack = readfile(fname, 'b')
-- 			let shada_objects = msgpackparse(mpack)
-- <		This will read ~/.config/nvim/shada/main.shada file to
-- 		`shada_objects` list.
--
-- 		Limitations:
-- 		1. Mapping ordering is not preserved unless messagepack
-- 		   mapping is dumped using generic  mapping
-- 		   (|msgpack-special-map|).
-- 		2. Since the parser aims to preserve all data untouched
-- 		   (except for 1.) some strings are parsed to
-- 		   |msgpack-special-dict| format which is not convenient to
-- 		   use.
-- 							*msgpack-special-dict*
-- 		Some messagepack strings may be parsed to special
-- 		dictionaries. Special dictionaries are dictionaries which
--
-- 		1. Contain exactly two keys: `_TYPE` and `_VAL`.
-- 		2. `_TYPE` key is one of the types found in |v:msgpack_types|
-- 		   variable.
-- 		3. Value for `_VAL` has the following format (Key column
-- 		   contains name of the key from |v:msgpack_types|):
--
-- 		Key	Value ~
-- 		nil	Zero, ignored when dumping.  Not returned by
-- 			|msgpackparse()| since |v:null| was introduced.
-- 		boolean	One or zero.  When dumping it is only checked that
-- 			value is a |Number|.  Not returned by |msgpackparse()|
-- 			since |v:true| and |v:false| were introduced.
-- 		integer	|List| with four numbers: sign (-1 or 1), highest two
-- 			bits, number with bits from 62nd to 31st, lowest 31
-- 			bits. I.e. to get actual number one will need to use
-- 			code like >
-- 				_VAL[0] * ((_VAL[1] << 62)
-- 				           & (_VAL[2] << 31)
-- 				           & _VAL[3])
-- <			Special dictionary with this type will appear in
-- 			|msgpackparse()| output under one of the following
-- 			circumstances:
-- 			1. |Number| is 32-bit and value is either above
-- 			   INT32_MAX or below INT32_MIN.
-- 			2. |Number| is 64-bit and value is above INT64_MAX. It
-- 			   cannot possibly be below INT64_MIN because msgpack
-- 			   C parser does not support such values.
-- 		float	|Float|. This value cannot possibly appear in
-- 			|msgpackparse()| output.
-- 		string	|readfile()|-style list of strings. This value will
-- 			appear in |msgpackparse()| output if string contains
-- 			zero byte or if string is a mapping key and mapping is
-- 			being represented as special dictionary for other
-- 			reasons.
-- 		binary	|readfile()|-style list of strings. This value will
-- 			appear in |msgpackparse()| output if binary string
-- 			contains zero byte.
-- 		array	|List|. This value cannot appear in |msgpackparse()|
-- 			output.
-- 							*msgpack-special-map*
-- 		map	|List| of |List|s with two items (key and value) each.
-- 			This value will appear in |msgpackparse()| output if
-- 			parsed mapping contains one of the following keys:
-- 			1. Any key that is not a string (including keys which
-- 			   are binary strings).
-- 			2. String with NUL byte inside.
-- 			3. Duplicate key.
-- 			4. Empty key.
-- 		ext	|List| with two values: first is a signed integer
-- 			representing extension type. Second is
-- 			|readfile()|-style list of strings.
--- @param list any[]
--- @return list
function vim.fn.msgpackparse(list) end

-- Returns a Dictionary with information about Insert mode
-- 		completion.  See |ins-completion|.
-- 		The items are:
-- 		   mode		Current completion mode name string.
-- 				See |complete_info_mode| for the values.
-- 		   pum_visible	|TRUE| if popup menu is visible.
-- 				See |pumvisible()|.
-- 		   items	List of completion matches.  Each item is a
-- 				dictionary containing the entries "word",
-- 				"abbr", "menu", "kind", "info" and "user_data".
-- 				See |complete-items|.
-- 		   selected	Selected item index.  First index is zero.
-- 				Index is -1 if no item is selected (showing
-- 				typed text only)
-- 		   inserted	Inserted string. [NOT IMPLEMENT YET]
--
-- 							*complete_info_mode*
-- 		mode values are:
-- 		   ""		     Not in completion mode
-- 		   "keyword"	     Keyword completion |i_CTRL-X_CTRL-N|
-- 		   "ctrl_x"	     Just pressed CTRL-X |i_CTRL-X|
-- 		   "whole_line"	     Whole lines |i_CTRL-X_CTRL-L|
-- 		   "files"	     File names |i_CTRL-X_CTRL-F|
-- 		   "tags"	     Tags |i_CTRL-X_CTRL-]|
-- 		   "path_defines"    Definition completion |i_CTRL-X_CTRL-D|
-- 		   "path_patterns"   Include completion |i_CTRL-X_CTRL-I|
-- 		   "dictionary"	     Dictionary |i_CTRL-X_CTRL-K|
-- 		   "thesaurus"	     Thesaurus |i_CTRL-X_CTRL-T|
-- 		   "cmdline"	     Vim Command line |i_CTRL-X_CTRL-V|
-- 		   "function"	     User defined completion |i_CTRL-X_CTRL-U|
-- 		   "omni"	     Omni completion |i_CTRL-X_CTRL-O|
-- 		   "spell"	     Spelling suggestions |i_CTRL-X_s|
-- 		   "eval"            |complete()| completion
-- 		   "unknown"	     Other internal modes
--
-- 		If the optional {what} list argument is supplied, then only
-- 		the items listed in {what} are returned.  Unsupported items in
-- 		{what} are silently ignored.
--
-- 		To get the position and size of the popup menu, see
-- 		|pum_getpos()|. It's also available in |v:event| during the
-- 		|CompleteChanged| event.
--
-- 		Examples: >
-- 			" Get all items
-- 			call complete_info()
-- 			" Get only 'mode'
-- 			call complete_info(['mode'])
-- 			" Get only 'mode' and 'pum_visible'
-- 			call complete_info(['mode', 'pum_visible'])
-- <
--- @return dict
function vim.fn.complete_info(what) end

-- Go to window with ID {expr}.  This may also change the current
-- 		tabpage.
-- 		Return 1 if successful, 0 if the window cannot be found.
--- @return number
function vim.fn.win_gotoid(expr) end

-- Adds a watcher to a dictionary. A dictionary watcher is
-- 		identified by three components:
--
-- 		- A dictionary({dict});
-- 		- A key pattern({pattern}).
-- 		- A function({callback}).
--
-- 		After this is called, every change on {dict} and on keys
-- 		matching {pattern} will result in {callback} being invoked.
--
-- 		For example, to watch all global variables: >
-- 			silent! call dictwatcherdel(g:, '*', 'OnDictChanged')
-- 			function! OnDictChanged(d,k,z)
-- 			  echomsg string(a:k) string(a:z)
-- 			endfunction
-- 			call dictwatcheradd(g:, '*', 'OnDictChanged')
-- <
-- 		For now {pattern} only accepts very simple patterns that can
-- 		contain a '*' at the end of the string, in which case it will
-- 		match every key that begins with the substring before the '*'.
-- 		That means if '*' is not the last character of {pattern}, only
-- 		keys that are exactly equal as {pattern} will be matched.
--
-- 		The {callback} receives three arguments:
--
-- 		- The dictionary being watched.
-- 		- The key which changed.
-- 		- A dictionary containing the new and old values for the key.
--
-- 		The type of change can be determined by examining the keys
-- 		present on the third argument:
--
-- 		- If contains both `old` and `new`, the key was updated.
-- 		- If it contains only `new`, the key was added.
-- 		- If it contains only `old`, the key was deleted.
--
-- 		This function can be used by plugins to implement options with
-- 		validation and parsing logic.
--- @param dict dictionary
--- @return start
function vim.fn.dictwatcheradd(dict, pattern, callback) end

-- Set tab-local variable {varname} to {val} in tab page {tabnr}.
-- 		|t:var|
-- 		Note that the variable name without "t:" must be used.
-- 		Tabs are numbered starting with one.
-- 		This function is not available in the |sandbox|.
--- @return set
function vim.fn.settabvar(nr, varname, val) end

-- Move the Vim server with the name {server} to the foreground.
-- 		This works like: >
-- 			remote_expr({server}, "foreground()")
-- <		Except that on Win32 systems the client does the work, to work
-- 		around the problem that the OS doesn't always allow the server
-- 		to bring itself to the foreground.
-- 		Note: This does not restore the window if it was minimized,
-- 		like foreground() does.
-- 		This function is not available in the |sandbox|.
-- 		{only in the Win32 GUI and the Win32 console version}
--- @return number
function vim.fn.remote_foreground(server) end

-- Set option or local variable {varname} in window {winnr} to
-- 		{val}.
-- 		Tabs are numbered starting with one.  For the current tabpage
-- 		use |setwinvar()|.
-- 		{winnr} can be the window number or the |window-ID|.
-- 		When {winnr} is zero the current window is used.
-- 		This also works for a global or local buffer option, but it
-- 		doesn't work for a global or local buffer variable.
-- 		For a local buffer option the global value is unchanged.
-- 		Note that the variable name without "w:" must be used.
-- 		Examples: >
-- 			:call settabwinvar(1, 1, "&list", 0)
-- 			:call settabwinvar(3, 2, "myvar", "foobar")
-- <		This function is not available in the |sandbox|.
--- @return set
function vim.fn.settabwinvar(tabnr, winnr, varname, val) end

-- Add a text property type {name}.  If a property type with this
-- 		name already exists an error is given.  Nothing is returned.
-- 		{props} is a dictionary with these optional fields:
-- 		   bufnr	define the property only for this buffer; this
-- 				avoids name collisions and automatically
-- 				clears the property types when the buffer is
-- 				deleted.
-- 		   highlight	name of highlight group to use
-- 		   priority	when a character has multiple text
-- 				properties the one with the highest priority
-- 				will be used; negative values can be used, the
-- 				default priority is zero
-- 		   combine	when TRUE combine the highlight with any
-- 				syntax highlight; when omitted or FALSE syntax
-- 				highlight will not be used
-- 		   start_incl	when TRUE inserts at the start position will
-- 				be included in the text property
-- 		   end_incl	when TRUE inserts at the end position will be
-- 				included in the text property
--
-- 		See |text-properties| for information about text properties.
--
-- 		Can also be used as a |method|: >
-- 			GetPropName()->prop_type_add(props)
--- @return none
function vim.fn.prop_type_add(name, props) end

-- Just like |popup_create()| but with these default options: >
-- 			call popup_create({what}, #{
-- 				\ pos: 'center',
-- 				\ zindex: 200,
-- 				\ drag: 1,
-- 				\ border: [],
-- 				\ padding: [],
-- 				\ mapping: 0,
-- 				\})
-- <		Use {options} to change the properties. E.g. add a 'filter'
-- 		option with value 'popup_filter_yesno'.  Example: >
-- 			call popup_create('do you want to quit (Yes/no)?', #{
-- 				\ filter: 'popup_filter_yesno',
-- 				\ callback: 'QuitCallback',
-- 				\ })
--
-- <		By default the dialog can be dragged, so that text below it
-- 		can be read if needed.
--
-- 		Can also be used as a |method|: >
-- 			GetText()->popup_dialog({})
--- @return number
function vim.fn.popup_dialog(what, options) end

-- FileType event has been triggered at least once.  Can be used
-- 		to avoid triggering the FileType event again in the scripts
-- 		that detect the file type. |FileType|
-- 		Returns |FALSE| when `:setf FALLBACK` was used.
-- 		When editing another file, the counter is reset, thus this
-- 		really checks if the FileType event has been triggered for the
-- 		current buffer.  This allows an autocommand that starts
-- 		editing another buffer to set 'filetype' and load a syntax
-- 		file.
--- @return number
function vim.fn.did_filetype() end

-- Returns Dictionary of |api-metadata|.
--
-- 		View it in a nice human-readable format: >
-- 		       :lua print(vim.inspect(vim.fn.api_info()))
--- @return dict
function vim.fn.api_info() end

-- Returns the number of filler lines above line {lnum}.
-- 		These are the lines that were inserted at this point in
-- 		another diff'ed window.  These filler lines are shown in the
-- 		display but don't exist in the buffer.
-- 		{lnum} is used like with |getline()|.  Thus "." is the current
-- 		line, "'m" mark m, etc.
-- 		Returns 0 if the current window is not in diff mode.
--- @return number
function vim.fn.diff_filler(lnum) end

-- Report a test failure directly, using {msg}.
-- 		Always returns one.
--- @return number
function vim.fn.assert_report(msg) end

-- Escape {string} for use as a shell command argument.
-- 		On Windows when 'shellslash' is not set, it
-- 		will enclose {string} in double quotes and double all double
-- 		quotes within {string}.
-- 		Otherwise, it will enclose {string} in single quotes and
-- 		replace all "'" with "'\''".
--
-- 		When the {special} argument is present and it's a non-zero
-- 		Number or a non-empty String (|non-zero-arg|), then special
-- 		items such as "!", "%", "#" and "<cword>" will be preceded by
-- 		a backslash.  This backslash will be removed again by the |:!|
-- 		command.
--
-- 		The "!" character will be escaped (again with a |non-zero-arg|
-- 		{special}) when 'shell' contains "csh" in the tail.  That is
-- 		because for csh and tcsh "!" is used for history replacement
-- 		even when inside single quotes.
--
-- 		With a |non-zero-arg| {special} the <NL> character is also
-- 		escaped.  When 'shell' containing "csh" in the tail it's
-- 		escaped a second time.
--
-- 		Example of use with a |:!| command: >
-- 		    :exe '!dir ' . shellescape(expand('<cfile>'), 1)
-- <		This results in a directory listing for the file under the
-- 		cursor.  Example of use with |system()|: >
-- 		    :call system("chmod +w -- " . shellescape(expand("%")))
-- <		See also |::S|.
--- @return string
function vim.fn.shellescape(string, special) end

-- Expand wildcards and the following special keywords in {expr}.
-- 		'wildignorecase' applies.
--
-- 		If {list} is given and it is |TRUE|, a List will be returned.
-- 		Otherwise the result is a String and when there are several
-- 		matches, they are separated by <NL> characters.
--
-- 		If the expansion fails, the result is an empty string.  A name
-- 		for a non-existing file is not included, unless {expr} does
-- 		not start with '%', '#' or '<', see below.
--
-- 		When {expr} starts with '%', '#' or '<', the expansion is done
-- 		like for the |cmdline-special| variables with their associated
-- 		modifiers.  Here is a short overview:
--
-- 			%		current file name
-- 			#		alternate file name
-- 			#n		alternate file name n
-- 			<cfile>		file name under the cursor
-- 			<afile>		autocmd file name
-- 			<abuf>		autocmd buffer number (as a String!)
-- 			<amatch>	autocmd matched name
-- 			<sfile>		sourced script file or function name
-- 			<slnum>		sourced script line number or function
-- 					line number
-- 			<sflnum>	script file line number, also when in
-- 					a function
-- 			<cword>		word under the cursor
-- 			<cWORD>		WORD under the cursor
-- 			<client>	the {clientid} of the last received
-- 					message |server2client()|
-- 		Modifiers:
-- 			:p		expand to full path
-- 			:h		head (last path component removed)
-- 			:t		tail (last path component only)
-- 			:r		root (one extension removed)
-- 			:e		extension only
--
-- 		Example: >
-- 			:let &tags = expand("%:p:h") . "/tags"
-- <		Note that when expanding a string that starts with '%', '#' or
-- 		'<', any following text is ignored.  This does NOT work: >
-- 			:let doesntwork = expand("%:h.bak")
-- <		Use this: >
-- 			:let doeswork = expand("%:h") . ".bak"
-- <		Also note that expanding "<cfile>" and others only returns the
-- 		referenced file name without further expansion.  If "<cfile>"
-- 		is "~/.cshrc", you need to do another expand() to have the
-- 		"~/" expanded into the path of the home directory: >
-- 			:echo expand(expand("<cfile>"))
-- <
-- 		There cannot be white space between the variables and the
-- 		following modifier.  The |fnamemodify()| function can be used
-- 		to modify normal file names.
--
-- 		When using '%' or '#', and the current or alternate file name
-- 		is not defined, an empty string is used.  Using "%:p" in a
-- 		buffer with no name, results in the current directory, with a
-- 		'/' added.
--
-- 		When {expr} does not start with '%', '#' or '<', it is
-- 		expanded like a file name is expanded on the command line.
-- 		'suffixes' and 'wildignore' are used, unless the optional
-- 		{nosuf} argument is given and it is |TRUE|.
-- 		Names for non-existing files are included.  The "**" item can
-- 		be used to search in a directory tree.  For example, to find
-- 		all "README" files in the current directory and below: >
-- 			:echo expand("**/README")
-- <
-- 		expand() can also be used to expand variables and environment
-- 		variables that are only known in a shell.  But this can be
-- 		slow, because a shell may be used to do the expansion.  See
-- 		|expr-env-expand|.
-- 		The expanded variable is still handled like a list of file
-- 		names.  When an environment variable cannot be expanded, it is
-- 		left unchanged.  Thus ":echo expand('$FOOBAR')" results in
-- 		"$FOOBAR".
--
-- 		See |glob()| for finding existing files.  See |system()| for
-- 		getting the raw output of an external command.
--- @param list any[]
function vim.fn.expand(expr, nosuf, list) end

-- Remove a previously placed sign in one or more buffers.  This
-- 		is similar to the |:sign-unplace| command.
--
-- 		{group} is the sign group name. To use the global sign group,
-- 		use an empty string.  If {group} is set to '*', then all the
-- 		groups including the global group are used.
-- 		The signs in {group} are selected based on the entries in
-- 		{dict}.  The following optional entries in {dict} are
-- 		supported:
-- 			buffer	buffer name or number. See |bufname()|.
-- 			id	sign identifier
-- 		If {dict} is not supplied, then all the signs in {group} are
-- 		removed.
--
-- 		Returns 0 on success and -1 on failure.
--
-- 		Examples: >
-- 			" Remove sign 10 from buffer a.vim
-- 			call sign_unplace('', {'buffer' : "a.vim", 'id' : 10})
--
-- 			" Remove sign 20 in group 'g1' from buffer 3
-- 			call sign_unplace('g1', {'buffer' : 3, 'id' : 20})
--
-- 			" Remove all the signs in group 'g2' from buffer 10
-- 			call sign_unplace('g2', {'buffer' : 10})
--
-- 			" Remove sign 30 in group 'g3' from all the buffers
-- 			call sign_unplace('g3', {'id' : 30})
--
-- 			" Remove all the signs placed in buffer 5
-- 			call sign_unplace('*', {'buffer' : 5})
--
-- 			" Remove the signs in group 'g4' from all the buffers
-- 			call sign_unplace('g4')
--
-- 			" Remove sign 40 from all the buffers
-- 			call sign_unplace('*', {'id' : 40})
--
-- 			" Remove all the placed signs from all the buffers
-- 			call sign_unplace('*')
--- @param dict dictionary
--- @return number
function vim.fn.sign_unplace(group, dict) end

-- Return a String that represents the time value of {time}.
-- 		This is the number of seconds, a dot and the number of
-- 		microseconds.  Example: >
-- 			let start = reltime()
-- 			call MyFunction()
-- 			echo reltimestr(reltime(start))
-- <		Note that overhead for the commands will be added to the time.
-- 		Leading spaces are used to make the string align nicely.  You
-- 		can use split() to remove it. >
-- 			echo split(reltimestr(reltime(start)))[0]
-- <		Also see |profiling|.
--- @return string
function vim.fn.reltimestr(time) end

-- Get character {index} from {str}.  This uses a character
-- 		index, not a byte index.  Composing characters are considered
-- 		separate characters here.
-- 		Also see |strcharpart()| and |strchars()|.
--- @return number
function vim.fn.strgetchar(str, index) end

-- {feature} argument is a feature name like "nvim-0.2.1" or
-- 		"win32", see below.  See also |exists()|.
--
-- 		Vim's compile-time feature-names (prefixed with "+") are not
-- 		recognized because Nvim is always compiled with all possible
-- 		features. |feature-compile|
--
-- 		Feature names can be:
-- 		1.  Nvim version. For example the "nvim-0.2.1" feature means
-- 		    that Nvim is version 0.2.1 or later: >
-- 			:if has("nvim-0.2.1")
--
-- <		2.  Runtime condition or other pseudo-feature. For example the
-- 		    "win32" feature checks if the current system is Windows: >
-- 			:if has("win32")
-- <							*feature-list*
-- 		    List of supported pseudo-feature names:
-- 		        acl		|ACL| support
-- 			bsd		BSD system (not macOS, use "mac" for that).
-- 		        iconv		Can use |iconv()| for conversion.
-- 		        +shellslash	Can use backslashes in filenames (Windows)
-- 			clipboard	|clipboard| provider is available.
-- 			mac		MacOS system.
-- 			nvim		This is Nvim.
-- 			python2		Legacy Vim |python2| interface. |has-python|
-- 			python3		Legacy Vim |python3| interface. |has-python|
-- 			pythonx		Legacy Vim |python_x| interface. |has-pythonx|
-- 			ttyin		input is a terminal (tty)
-- 			ttyout		output is a terminal (tty)
-- 			unix		Unix system.
-- 			*vim_starting*	True during |startup|.
-- 			win32		Windows system (32 or 64 bit).
-- 			win64		Windows system (64 bit).
-- 			wsl		WSL (Windows Subsystem for Linux) system
--
-- 							*has-patch*
-- 		3.  Vim patch. For example the "patch123" feature means that
-- 		    Vim patch 123 at the current |v:version| was included: >
-- 			:if v:version > 602 || v:version == 602 && has("patch148")
--
-- <		4.  Vim version. For example the "patch-7.4.237" feature means
-- 		    that Nvim is Vim-compatible to version 7.4.237 or later. >
-- 			:if has("patch-7.4.237")
--- @return number
function vim.fn.has(feature) end

-- Open the buffer {expr} or jump to the window that contains
-- 		{expr} and position the cursor at sign {id} in group {group}.
-- 		This is similar to the |:sign-jump| command.
--
-- 		For the use of {expr}, see |bufname()|.
--
-- 		Returns the line number of the sign. Returns -1 if the
-- 		arguments are invalid.
--
-- 		Example: >
-- 			" Jump to sign 10 in the current buffer
-- 			call sign_jump(10, '', '')
-- <
--- @return number
function vim.fn.sign_jump(id, group, expr) end

-- Confirm() offers the user a dialog, from which a choice can be
-- 		made.  It returns the number of the choice.  For the first
-- 		choice this is 1.
--
-- 		{msg} is displayed in a dialog with {choices} as the
-- 		alternatives.  When {choices} is missing or empty, "&OK" is
-- 		used (and translated).
-- 		{msg} is a String, use '\n' to include a newline.  Only on
-- 		some systems the string is wrapped when it doesn't fit.
--
-- 		{choices} is a String, with the individual choices separated
-- 		by '\n', e.g. >
-- 			confirm("Save changes?", "&Yes\n&No\n&Cancel")
-- <		The letter after the '&' is the shortcut key for that choice.
-- 		Thus you can type 'c' to select "Cancel".  The shortcut does
-- 		not need to be the first letter: >
-- 			confirm("file has been modified", "&Save\nSave &All")
-- <		For the console, the first letter of each choice is used as
-- 		the default shortcut key.
--
-- 		The optional {default} argument is the number of the choice
-- 		that is made if the user hits <CR>.  Use 1 to make the first
-- 		choice the default one.  Use 0 to not set a default.  If
-- 		{default} is omitted, 1 is used.
--
-- 		The optional {type} argument gives the type of dialog.  This
-- 		is only used for the icon of the Win32 GUI.  It can be one of
-- 		these values: "Error", "Question", "Info", "Warning" or
-- 		"Generic".  Only the first character is relevant.
-- 		When {type} is omitted, "Generic" is used.
--
-- 		If the user aborts the dialog by pressing <Esc>, CTRL-C,
-- 		or another valid interrupt key, confirm() returns 0.
--
-- 		An example: >
--    :let choice = confirm("What do you want?", "&Apples\n&Oranges\n&Bananas", 2)
--    :if choice == 0
--    :	echo "make up your mind!"
--    :elseif choice == 3
--    :	echo "tasteful"
--    :else
--    :	echo "I prefer bananas myself."
--    :endif
-- <		In a GUI dialog, buttons are used.  The layout of the buttons
-- 		depends on the 'v' flag in 'guioptions'.  If it is included,
-- 		the buttons are always put vertically.  Otherwise,  confirm()
-- 		tries to put the buttons in one horizontal line.  If they
-- 		don't fit, a vertical layout is used anyway.  For some systems
-- 		the horizontal layout is always used.
--- @return number
function vim.fn.confirm(msg, choices, default, type) end

-- Return the number of lines that scrolled to above the top of
-- 		terminal {buf}.  This is the offset between the row number
-- 		used for |term_getline()| and |getline()|, so that: >
-- 			term_getline(buf, N)
-- <		is equal to: >
-- 			getline(N + term_getscrolled(buf))
-- <		(if that line exists).
--
-- 		{buf} is used as with |term_getsize()|.
--
-- 		Can also be used as a |method|: >
-- 			GetBufnr()->term_getscrolled()
--- @return number
function vim.fn.term_getscrolled(buf) end

-- Get the |window-ID| for the popup info window, as it used by
-- 		the popup menu.  See |complete-popup|.  The info popup is
-- 		hidden when not used, it can be deleted with |popup_clear()|
-- 		and |popup_close()|.  Use |popup_show()| to reposition it to
-- 		the item in the popup menu.
-- 		Returns zero if there is none.
--- @return number
function vim.fn.popup_findinfo() end

-- Add a buffer to the buffer list with {name}.
-- 		If a buffer for file {name} already exists, return that buffer
-- 		number.  Otherwise return the buffer number of the newly
-- 		created buffer.  When {name} is an empty string then a new
-- 		buffer is always created.
-- 		The buffer will not have' 'buflisted' set.
--- @return number
function vim.fn.bufadd(name) end

-- Simplify the file name as much as possible without changing
-- 		the meaning.  Shortcuts (on MS-Windows) or symbolic links (on
-- 		Unix) are not resolved.  If the first path component in
-- 		{filename} designates the current directory, this will be
-- 		valid for the result as well.  A trailing path separator is
-- 		not removed either.
-- 		Example: >
-- 			simplify("./dir/.././/file/") == "./file/"
-- <		Note: The combination "dir/.." is only removed if "dir" is
-- 		a searchable directory or does not exist.  On Unix, it is also
-- 		removed when "dir" is a symbolic link within the same
-- 		directory.  In order to resolve all the involved symbolic
-- 		links before simplifying the path name, use |resolve()|.
--- @return string
function vim.fn.simplify(filename) end

-- Return the line number of the first line at or above {lnum}
-- 		that is not blank.  Example: >
-- 			let ind = indent(prevnonblank(v:lnum - 1))
-- <		When {lnum} is invalid or there is no non-blank line at or
-- 		above it, zero is returned.
-- 		Also see |nextnonblank()|.
--- @return number
function vim.fn.prevnonblank(lnum) end

-- Convert {expr} into a JSON string.  Accepts
-- 		|msgpack-special-dict| as the input.  Will not convert
-- 		|Funcref|s, mappings with non-string keys (can be created as
-- 		|msgpack-special-dict|), values with self-referencing
-- 		containers, strings which contain non-UTF-8 characters,
-- 		pseudo-UTF-8 strings which contain codepoints reserved for
-- 		surrogate pairs (such strings are not valid UTF-8 strings).
-- 		Non-printable characters are converted into "\u1234" escapes
-- 		or special escapes like "\t", other are dumped as-is.
--- @return string
function vim.fn.json_encode(expr) end

-- Unstabilized interface for defining syntax hl in lua.
--
--                 This is not yet safe for general use, lua callbacks will need
--                 to be restricted, like textlock and probably other stuff.
--
--                 The API on_line/nvim__put_attr is quite raw and not intended
--                 to be the final shape. Ideally this should operate on chunks
--                 larger than a single line to reduce interpreter overhead, and
--                 generate annotation objects (bufhl/virttext) on the fly but
--                 using the same representation.
function vim.fn.nvim__buf_set_luahl(buffer, opts) end

-- Connect a socket to an address. If {mode} is "pipe" then
-- 		{address} should be the path of a named pipe. If {mode} is
-- 		"tcp" then {address} should be of the form "host:port" where
-- 		the host should be an ip adderess or host name, and port the
-- 		port number.
--
-- 		Returns a |channel| ID. Close the socket with |chanclose()|.
-- 		Use |chansend()| to send data over a bytes socket, and
-- 		|rpcrequest()| and |rpcnotify()| to communicate with a RPC
-- 		socket.
--
-- 		{opts} is a dictionary with these keys:
-- 		  |on_data| : callback invoked when data was read from socket
-- 		  data_buffered : read socket data in |channel-buffered| mode.
-- 		  rpc     : If set, |msgpack-rpc| will be used to communicate
-- 			    over the socket.
-- 		Returns:
-- 		  - The channel ID on success (greater than zero)
-- 		  - 0 on invalid arguments or connection failure.
--- @return number
function vim.fn.sockconnect(mode, address, opts) end

-- Expand special items in {expr} like what is done for an Ex
-- 		command such as `:edit`.  This expands special keywords, like
-- 		with |expand()|, and environment variables, anywhere in
-- 		{expr}.  Returns the expanded string.
-- 		Example: >
-- 			:echo expandcmd('make %<.o')
--- @return string
function vim.fn.expandcmd(expr) end

-- Return the non-negative square root of Float {expr} as a
-- 		|Float|.
-- 		{expr} must evaluate to a |Float| or a |Number|.  When {expr}
-- 		is negative the result is NaN (Not a Number).
-- 		Examples: >
-- 			:echo sqrt(100)
-- <			10.0 >
-- 			:echo sqrt(-4.01)
-- <			nan
-- 		"nan" may be different, it depends on system libraries.
--- @return float
function vim.fn.sqrt(expr) end

-- Return the sound-folded equivalent of {word}.  Uses the first
-- 		language in 'spelllang' for the current window that supports
-- 		soundfolding.  'spell' must be set.  When no sound folding is
-- 		possible the {word} is returned unmodified.
-- 		This can be used for making spelling suggestions.  Note that
-- 		the method can be quite slow.
--- @return string
function vim.fn.soundfold(word) end

-- Return all of environment variables as dictionary. You can
-- 		check if an environment variable exists like this: >
-- 			:echo has_key(environ(), 'HOME')
-- <		Note that the variable name may be CamelCase; to ignore case
-- 		use this: >
-- 			:echo index(keys(environ()), 'HOME', 0, 1) != -1
--- @return dict
function vim.fn.environ() end

-- The result is a Number, which is 1 when a file with the
-- 		name {file} exists, and can be written.  If {file} doesn't
-- 		exist, or is not writable, the result is 0.  If {file} is a
-- 		directory, and we can write to it, the result is 2.
--- @return number
function vim.fn.filewritable(file) end

-- Insert {item} at the start of |List| {list}.
-- 		If {idx} is specified insert {item} before the item with index
-- 		{idx}.  If {idx} is zero it goes before the first item, just
-- 		like omitting {idx}.  A negative {idx} is also possible, see
-- 		|list-index|.  -1 inserts just before the last item.
-- 		Returns the resulting |List|.  Examples: >
-- 			:let mylist = insert([2, 3, 5], 1)
-- 			:call insert(mylist, 4, -1)
-- 			:call insert(mylist, 6, len(mylist))
-- <		The last example can be done simpler with |add()|.
-- 		Note that when {item} is a |List| it is inserted as a single
-- 		item.  Use |extend()| to concatenate |Lists|.
--- @param list any[]
--- @return list
function vim.fn.insert(list, item, idx) end

